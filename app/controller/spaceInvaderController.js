const Winner = require('../model/winner');
const validator = require('validator');
const {
    formatLongBDD
} = require('../service/date');
const {
    formatToast
} = require('../service/date');
const {sendEmailWithIp} = require("../service/sendMail");




const spaceInvaderController = {

    findWinners: async (req, res) => {
        try {

            const allWinners = await Winner.findAllWithoutIpAndDate();
            console.log("allWinners in spaceInvaderController ===> ", allWinners);

            return res.status(404).render(`erreur`, {
                allWinners
            });

        } catch (error) {
            console.log("Erreur dans la m√©thode findWinners du spaceInvaderController : ", error);
            return res.status(500).end();
        }
    },

    insertWinner: async (req, res) => {
        try {
            // je r√©cup√©re le nom, le prenom, et le score 
            const nom = validator.trim(req.body.nom);
            const prenom = validator.trim(req.body.prenom);

            //nom et prenom ne doivent pas d√©passer 30 caract√©res et score doit √™tre un entier entre 999 et 9999.
            if (!validator.isInt(req.body.score, {
                    min: 799,
                    max: 9999
                })) {
                console.log("Erreur dans les score !");
                const allWinners = await Winner.findAllWithoutIpAndDate();
                return res.status(404).render(`erreur`, {
                    allWinners
                });
            }

            const score = parseInt(req.body.score, 10);

            //mais aussi l'IP et la date,
            const clientIp = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
            console.log("clientip ==> ", clientIp);



            if (nom.length > 30 || prenom.length > 30 || nom.length < 3 || prenom.length < 3) {
                console.log("Erreur dans la longeur des nom / pr√©nom !");
                const allWinners = await Winner.findAllWithoutIpAndDate();
                const message = " Votre nom et votre pr√©nom, doivent comprendre, chacun, entre 3 et 30 caract√©res.";
                return res.status(404).render('erreurWithModal', {
                    allWinners,
                    score,
                    message
                });

            }

            //! check, si le nom et le prenom existe d√©ja existe, et les IP ne sont pas les m√™me on refuse ! et on renvoie la modale por un nouveau choix. 
            //! Sinon, on v√©rifie si le score est sup√©rieur, et seulement si c'est la cas, on update !

            const allWinnersBefore = await Winner.findAll();


            // On pr√©pare et mutualise notre objet que l'on passera au model avec une m√©thode d'instance :
            const doc = {
                nom,
                prenom,
                ip: `${clientIp}`,
                score,
                createdDate: formatLongBDD(),
            };

            // J'envoie un petit email a l'admin pour lui faire part de la bonne nouvelle !
            const contexte = {
                nom,
                prenom,
                score,
                createdDate: formatLongBDD(),
            };
            const emailSend = process.env.MYEMAIL;
            const template = 'winner';
            const text = `Un nouveau gagnant au space invader avec ${score} points ! Donn√©e => nom:${nom}, pr√©nom:${prenom}, date:${formatLongBDD()}`;
            const subject = `Un nouveau gagnant au space invader avec ${score} points !`;
            const infoEmail = await sendEmailWithIp(emailSend, subject, contexte, text, template, clientIp);
            if (typeof infoEmail === undefined) {
            console.log("Une √©rreur est survenue lors de l'envoie, merci de r√©essayer.");
            } else {
                console.log("Votre message a bien √©t√© envoy√© !");
            }


            //si on a aucun score d√©ja pres√©nt, on peut pas 'find' sur du null..
            if (allWinnersBefore !== null) {


                // je v√©rifie si le nom propos√© existe d√©ja en BDD . Si undefined : pas de doublon
                const isNameFound = allWinnersBefore.find(bdd => bdd.nom === nom && bdd.prenom === prenom);

                if (isNameFound !== undefined) {
                    //Un doublon existe, je v√©rifie l'IP :
                    if (clientIp === isNameFound.ip) {

                        // IP identique : je v√©rifie les scores :
                        // On ne met a jour le score uniquement si le nouveau score est sup√©rieur a l'ancien...
                        if (score > isNameFound.score) {

                            //Le nouveau score est sup√©rieur, je l'update !

                            const dataToSend = {
                                filter: {
                                    nom: nom
                                },
                                updateobj: {
                                    $set: {
                                        score: score
                                    }
                                },
                            }


                            //Personalisation du message selon l'ip, dans deux cas !
                            if (clientIp === '88.163.249.23') {

                                const updateWinner = new Winner(dataToSend);
                                const updateWinnerDone = await updateWinner.update();

                                if (updateWinnerDone === null) {

                                    console.log("Erreur dans la m√©thode insertWinner du spaceinvaderController, Le retour de l'update de doit pas √™tre null ! ");
                                    return res.status(500).end()
                                }

                                const allWinners = await Winner.findAllWithoutIpAndDate();
                                const toastMessage = " Ho ! Il me semble que l'on se connait...! üòò Ton score est √† jour ! üéâ ";
                                const toastDate = await formatToast();
                                return res.status(404).render(`erreur`, {
                                    allWinners,
                                    toastDate,
                                    toastMessage
                                });


                            };

                            if (clientIp === '86.227.129.119') {

                                const updateWinner = new Winner(dataToSend);
                                const updateWinnerDone = await updateWinner.update();

                                if (updateWinnerDone === null) {

                                    console.log("Erreur dans la m√©thode insertWinner du spaceinvaderController, Le retour de l'update de doit pas √™tre null ! ");
                                    return res.status(500).end()
                                }

                                const allWinners = await Winner.findAllWithoutIpAndDate();
                                const toastMessage = " Ho ! Enchant√© cher colloc ! ‚úåÔ∏è  Ton score est √† jour ! üéâ";
                                const toastDate = await formatToast();
                                return res.status(404).render(`erreur`, {
                                    allWinners,
                                    toastDate,
                                    toastMessage
                                });


                            }


                            // si ip inconnue..
                            const updateWinner = new Winner(dataToSend);
                            const updateWinnerDone = await updateWinner.update();

                            if (updateWinnerDone === null) {

                                console.log("Erreur dans la m√©thode insertWinner du spaceinvaderController, Le retour de l'update de doit pas √™tre null ! ");
                                return res.status(500).end()
                            }



                            const allWinners = await Winner.findAllWithoutIpAndDate();
                            const toastMessage = "Votre score a √©t√© mis √† jour avec succ√©s ! üéâ ";
                            const toastDate = await formatToast();
                            return res.status(404).render('erreur', {
                                allWinners,
                                toastMessage,
                                toastDate
                            });

                        }

                        // Le nouveau score est inf√©rieur, on renvoie la modale en expliquant ce qui se passe :
                        const allWinners = await Winner.findAllWithoutIpAndDate();
                        const message = "Ce nom et ce pr√©nom sont d√©ja existant. Votre adresse ip √©tant la m√™me que celle qui a servit √† r√©aliser le pr√©c√©dant score avec ce m√™me nom et pr√©nom, vous pouvez mettre √† jour votre score en gardant le nom et pr√©nom du pr√©c√©dent score. N√©anmoins, comme votre score actuel est inf√©rieur au pr√©c√©dent score r√©alis√©, celui-√ßi n'a donc pas √©t√© enregistr√© !";
                        return res.status(404).render('erreurWithModalInfo', {
                            allWinners,
                            score,
                            message
                        });


                    }



                    // Si pas la m√™me ip => on n'autorise pas ce nom...
                    //On renvoie la page avec la modal ouverte
                    const allWinners = await Winner.findAllWithoutIpAndDate();
                    // on renvoie √©galement le score a la vue...
                    const message = "Ces nom et pr√©nom sont d√©ja existant, merci de choisir un nom et/ou un pr√©nom diff√©rent.";
                    return res.status(404).render('erreurWithModal', {
                        allWinners,
                        score,
                        message
                    });
                };



                if (clientIp === '88.163.249.23') {

                    const newWinner = new Winner(doc);
                    const newWinnerInsert = await newWinner.insert();

                    if (newWinnerInsert === null) {
                        console.log("Erreur dans la m√©thode insertWinner du spaceinvaderController, Le retour de l'insert de doit pas √™tre null (L154) ! ");
                        return res.status(500).end()
                    }

                    const allWinners = await Winner.findAllWithoutIpAndDate();
                    const toastMessage = " Ho ! Il me semble que l'on se connait... ! üòò";
                    const toastDate = await formatToast();
                    return res.status(404).render(`erreur`, {
                        allWinners,
                        toastDate,
                        toastMessage
                    });


                }

                if (clientIp === '86.227.129.119') {

                    const newWinner = new Winner(doc);
                    const newWinnerInsert = await newWinner.insert();

                    if (newWinnerInsert === null) {
                        console.log("Erreur dans la m√©thode insertWinner du spaceinvaderController, Le retour de l'insert de doit pas √™tre null (L154) ! ");
                        return res.status(500).end()
                    }

                    const allWinners = await Winner.findAllWithoutIpAndDate();
                    const toastMessage = " Ho ! Enchant√© cher colloc ! ‚úåÔ∏è ";
                    const toastDate = await formatToast();
                    return res.status(404).render(`erreur`, {
                        allWinners,
                        toastDate,
                        toastMessage
                    });


                }


                // on insert des donn√©e en BDD => m√©thode d'instance
                const newWinner = new Winner(doc);
                const newWinnerInsert = await newWinner.insert();

                if (newWinnerInsert === null) {
                    console.log("Erreur dans la m√©thode insertWinner du spaceinvaderController, Le retour de l'insert de doit pas √™tre null (L154) ! ");
                    return res.status(500).end()
                }

                const allWinners = await Winner.findAllWithoutIpAndDate();
                const toastMessage = " Vos nom et pr√©nom ont bien √©t√© enregistr√©s avec votre score ! üéä ";
                const toastDate = await formatToast();
                return res.status(404).render(`erreur`, {
                    allWinners,
                    toastDate,
                    toastMessage
                });


            };


            // on insert des donn√©e en BDD => m√©thode d'instance
            const newWinner = new Winner(doc);
            const newWinnerInsert = await newWinner.insert();

            if (newWinnerInsert === null) {
                console.log("Erreur dans la m√©thode insertWinner du spaceinvaderController, Le retour de l'insert de doit pas √™tre null (L182) ! ");
                return res.status(500).end()
            }

            const allWinners = await Winner.findAllWithoutIpAndDate();
            const toastMessage = " üéä Vous √™tes le premier √† avoir repouss√© l'invasion ! votre score restera grav√© pour l'√©ternit√© ! üéä";
            const toastDate = await formatToast();
            return res.status(404).render(`erreur`, {
                allWinners,
                toastDate,
                toastMessage
            });


        } catch (error) {
            console.log("Erreur dans la m√©thode insert du spaceInvaderController : ", error);
            return res.status(500).end();
        }
    },





}

module.exports = spaceInvaderController;